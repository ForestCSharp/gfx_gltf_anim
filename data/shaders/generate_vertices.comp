#version 450
#extension GL_ARB_separate_shader_objects : enable
#extension GL_GOOGLE_include_directive : require

// minimal SVD implementation for calculating feature points from hermite data
// works in C++ and GLSL

// public domain

// SVD
////////////////////////////////////////////////////////////////////////////////

#define SVD_NUM_SWEEPS 5

const float Tiny_Number = 1.e-20;

void givens_coeffs_sym(float a_pp, float a_pq, float a_qq, out float c, out float s) 
{
    if (a_pq == 0.0) 
    {
        c = 1.0;
        s = 0.0;
        return;
    }
    float tau = (a_qq - a_pp) / (2.0 * a_pq);
    float stt = sqrt(1.0 + tau * tau);
    float tan = 1.0 / ((tau >= 0.0) ? (tau + stt) : (tau - stt));
    c = inversesqrt(1.0 + tan * tan);
    s = tan * c;
}

void svd_rotate_xy(inout float x, inout float y, in float c, in float s) 
{
    float u = x; float v = y;
    x = c * u - s * v;
    y = s * u + c * v;
}

void svd_rotateq_xy(inout float x, inout float y, inout float a, in float c, in float s) 
{
    float cc = c * c; float ss = s * s;
    float mx = 2.0 * c * s * a;
    float u = x; float v = y;
    x = cc * u - mx + ss * v;
    y = ss * u + mx + cc * v;
}

void svd_rotate(inout mat3 vtav, inout mat3 v, in int a, in int b) 
{
    if (vtav[a][b] == 0.0) 
    { 
        return;
    }
    
    float c, s;
    givens_coeffs_sym(vtav[a][a], vtav[a][b], vtav[b][b], c, s);
    svd_rotateq_xy(vtav[a][a],vtav[b][b],vtav[a][b],c,s);
    svd_rotate_xy(vtav[0][3-b], vtav[1-a][2], c, s);
    vtav[a][b] = 0.0;
    
    svd_rotate_xy(v[0][a], v[0][b], c, s);
    svd_rotate_xy(v[1][a], v[1][b], c, s);
    svd_rotate_xy(v[2][a], v[2][b], c, s);
}

void svd_solve_sym(in mat3 a, out vec3 sigma, inout mat3 v) 
{
    // assuming that A is symmetric: can optimize all operations for 
    // the upper right triagonal
    mat3 vtav = a;
    // assuming V is identity: you can also pass a matrix the rotations
    // should be applied to
    // U is not computed
    for (int i = 0; i < SVD_NUM_SWEEPS; ++i) 
    {
        svd_rotate(vtav, v, 0, 1);
        svd_rotate(vtav, v, 0, 2);
        svd_rotate(vtav, v, 1, 2);
    }
    sigma = vec3(vtav[0][0],vtav[1][1],vtav[2][2]);    
}

float svd_invdet(float x, float tol) 
{
    return (abs(x) < tol || abs(1.0 / x) < tol) ? 0.0 : (1.0 / x);
}

void svd_pseudoinverse(out mat3 o, in vec3 sigma, in mat3 v) 
{
    float d0 = svd_invdet(sigma[0], Tiny_Number);
    float d1 = svd_invdet(sigma[1], Tiny_Number);
    float d2 = svd_invdet(sigma[2], Tiny_Number);
    o = mat3(v[0][0] * d0 * v[0][0] + v[0][1] * d1 * v[0][1] + v[0][2] * d2 * v[0][2],
             v[0][0] * d0 * v[1][0] + v[0][1] * d1 * v[1][1] + v[0][2] * d2 * v[1][2],
             v[0][0] * d0 * v[2][0] + v[0][1] * d1 * v[2][1] + v[0][2] * d2 * v[2][2],
             v[1][0] * d0 * v[0][0] + v[1][1] * d1 * v[0][1] + v[1][2] * d2 * v[0][2],
             v[1][0] * d0 * v[1][0] + v[1][1] * d1 * v[1][1] + v[1][2] * d2 * v[1][2],
             v[1][0] * d0 * v[2][0] + v[1][1] * d1 * v[2][1] + v[1][2] * d2 * v[2][2],
             v[2][0] * d0 * v[0][0] + v[2][1] * d1 * v[0][1] + v[2][2] * d2 * v[0][2],
             v[2][0] * d0 * v[1][0] + v[2][1] * d1 * v[1][1] + v[2][2] * d2 * v[1][2],
             v[2][0] * d0 * v[2][0] + v[2][1] * d1 * v[2][1] + v[2][2] * d2 * v[2][2]);
}

void svd_solve_ATA_ATb(in mat3 ATA, in vec3 ATb, out vec3 x) 
{
    mat3 V = mat3(1.0);
    vec3 sigma;
    
    svd_solve_sym(ATA, sigma, V);
    
    // A = UEV^T; U = A / (E*V^T)
    mat3 Vinv;
    svd_pseudoinverse(Vinv, sigma, V);
    x = Vinv * ATb;
}

vec3 svd_vmul_sym(in mat3 a, in vec3 v) 
{
    return vec3(
        dot(a[0],v),
        (a[0][1] * v.x) + (a[1][1] * v.y) + (a[1][2] * v.z),
        (a[0][2] * v.x) + (a[1][2] * v.y) + (a[2][2] * v.z)
    );
}

void svd_mul_ata_sym(out mat3 o, in mat3 a)
{
    o[0][0] = a[0][0] * a[0][0] + a[1][0] * a[1][0] + a[2][0] * a[2][0];
    o[0][1] = a[0][0] * a[0][1] + a[1][0] * a[1][1] + a[2][0] * a[2][1];
    o[0][2] = a[0][0] * a[0][2] + a[1][0] * a[1][2] + a[2][0] * a[2][2];
    o[1][1] = a[0][1] * a[0][1] + a[1][1] * a[1][1] + a[2][1] * a[2][1];
    o[1][2] = a[0][1] * a[0][2] + a[1][1] * a[1][2] + a[2][1] * a[2][2];
    o[2][2] = a[0][2] * a[0][2] + a[1][2] * a[1][2] + a[2][2] * a[2][2];
}
    
void svd_solve_Ax_b(in mat3 a, in vec3 b, out mat3 ATA, out vec3 ATb, out vec3 x) 
{
    svd_mul_ata_sym(ATA, a);
    ATb = b * a; // transpose(a) * b;
    svd_solve_ATA_ATb(ATA, ATb, x);
}

// QEF
////////////////////////////////////////////////////////////////////////////////

void qef_add( in vec3 n, in vec3 p, inout mat3 ATA, inout vec3 ATb, inout vec4 pointaccum)
{ 
    ATA[0][0] += n.x * n.x;
    ATA[0][1] += n.x * n.y;
    ATA[0][2] += n.x * n.z;
    ATA[1][1] += n.y * n.y;
    ATA[1][2] += n.y * n.z;
    ATA[2][2] += n.z * n.z;

    float b = dot(p, n);
    ATb += n * b;
    pointaccum += vec4(p,1.0);
}

float qef_calc_error(in mat3 A, in vec3 x, in vec3 b) 
{
    vec3 vtmp = b - svd_vmul_sym(A, x);
    return dot(vtmp,vtmp);
}

float qef_solve(in mat3 ATA, in vec3 ATb, in vec4 pointaccum, out vec3 x) 
{
    vec3 masspoint = pointaccum.xyz / pointaccum.w;
    ATb -= svd_vmul_sym(ATA, masspoint);
    svd_solve_ATA_ATb(ATA, ATb, x);
    float result = qef_calc_error(ATA, x, ATb);
    
    x += masspoint;
        
    return result;
}

//Example Code

// int main(void) {
//     vec4 pointaccum = vec4(0.0);
//     mat3 ATA = mat3(0.0);
//     vec3 ATb = vec3(0.0);
    
//     #define COUNT 5
//     vec3 normals[COUNT] = {
//         normalize(vec3( 1.0,1.0,0.0)),
//         normalize(vec3( 1.0,1.0,0.0)),
//         normalize(vec3(-1.0,1.0,0.0)),
//         normalize(vec3(-1.0,2.0,1.0)),
//         //normalize(vec3(-1.0,1.0,0.0)),
//         normalize(vec3(-1.0,1.0,0.0)),
//     };
//     vec3 points[COUNT] = {
//         vec3(  1.0,0.0,0.3),
//         vec3(  0.9,0.1,-0.5),
//         vec3( -0.8,0.2,0.6),
//         vec3( -1.0,0.0,0.01),
//         vec3( -1.1,-0.1,-0.5),
//     };
    
//     for (int i= 0; i < COUNT; ++i) {
//         qef_add(normals[i],points[i],ATA,ATb,pointaccum);
//     }
//     vec3 com = pointaccum.xyz / pointaccum.w;
    
//     vec3 x;
//     float error = qef_solve(ATA,ATb,pointaccum,x);

//     printf("masspoint = (%.5f %.5f %.5f)\n", com.x, com.y, com.z);
//     printf("point = (%.5f %.5f %.5f)\n", x.x, x.y, x.z);
//     printf("error = %.5f\n", error);

// #if SVD_COMPARE_REFERENCE
//     double a[COUNT*3];
//     double b[COUNT];
    
//     for (int i = 0; i < COUNT; ++i) {
//         b[i] = (points[i].x - com.x)*normals[i].x
//              + (points[i].y - com.y)*normals[i].y
//              + (points[i].z - com.z)*normals[i].z;
//         a[i] = normals[i].x;
//         a[i+COUNT] = normals[i].y;
//         a[i+2*COUNT] = normals[i].z;
//     }
    
//     double *c = svd_solve(5,3,a,b,0.1);
    
//     vec3 result = com + vec3(c[0], c[1], c[2]);
//     r8_free(c);
//     printf("reference="); dump_vec3(result);
// #endif
    
//     return 0;
// }
// #endif

// #endif

layout (local_size_x = 1, local_size_y = 1, local_size_z = 1 ) in;

struct Vertex
{
    vec4 position;
    vec4 normal;
};

layout(std430, binding = 0) buffer vertices_buffer
{
    Vertex vertices[];
};

layout(std430, binding = 1) buffer indices_buffer 
{
    int indices[][18];
};

//TODO: Put offset of this dual-contour space here (as well as any other config vars)
layout(std140, binding = 2) uniform ComputeUniform 
{
    vec4 offset;
    float voxel_size;
} settings;

//	Simplex 3D Noise 
//	by Ian McEwan, Ashima Arts
//
vec4 permute(vec4 x){return mod(((x*34.0)+1.0)*x, 289.0);}
vec4 taylorInvSqrt(vec4 r){return 1.79284291400159 - 0.85373472095314 * r;}

float snoise(vec3 v){ 
  const vec2  C = vec2(1.0/6.0, 1.0/3.0) ;
  const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);

// First corner
  vec3 i  = floor(v + dot(v, C.yyy) );
  vec3 x0 =   v - i + dot(i, C.xxx) ;

// Other corners
  vec3 g = step(x0.yzx, x0.xyz);
  vec3 l = 1.0 - g;
  vec3 i1 = min( g.xyz, l.zxy );
  vec3 i2 = max( g.xyz, l.zxy );

  //  x0 = x0 - 0. + 0.0 * C 
  vec3 x1 = x0 - i1 + 1.0 * C.xxx;
  vec3 x2 = x0 - i2 + 2.0 * C.xxx;
  vec3 x3 = x0 - 1. + 3.0 * C.xxx;

// Permutations
  i = mod(i, 289.0 ); 
  vec4 p = permute( permute( permute( 
             i.z + vec4(0.0, i1.z, i2.z, 1.0 ))
           + i.y + vec4(0.0, i1.y, i2.y, 1.0 )) 
           + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));

// Gradients
// ( N*N points uniformly over a square, mapped onto an octahedron.)
  float n_ = 1.0/7.0; // N=7
  vec3  ns = n_ * D.wyz - D.xzx;

  vec4 j = p - 49.0 * floor(p * ns.z *ns.z);  //  mod(p,N*N)

  vec4 x_ = floor(j * ns.z);
  vec4 y_ = floor(j - 7.0 * x_ );    // mod(j,N)

  vec4 x = x_ *ns.x + ns.yyyy;
  vec4 y = y_ *ns.x + ns.yyyy;
  vec4 h = 1.0 - abs(x) - abs(y);

  vec4 b0 = vec4( x.xy, y.xy );
  vec4 b1 = vec4( x.zw, y.zw );

  vec4 s0 = floor(b0)*2.0 + 1.0;
  vec4 s1 = floor(b1)*2.0 + 1.0;
  vec4 sh = -step(h, vec4(0.0));

  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;
  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;

  vec3 p0 = vec3(a0.xy,h.x);
  vec3 p1 = vec3(a0.zw,h.y);
  vec3 p2 = vec3(a1.xy,h.z);
  vec3 p3 = vec3(a1.zw,h.w);

//Normalise gradients
  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));
  p0 *= norm.x;
  p1 *= norm.y;
  p2 *= norm.z;
  p3 *= norm.w;

// Mix final noise value
  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);
  m = m * m;
  return 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1), 
                                dot(p2,x2), dot(p3,x3) ) );
}

float fbm(in vec3 position, int octaves)
{
    float value = 0.0;
    float amplitude = 0.5;
    float frequency = 0.0;

    for (int i=0; i < octaves; ++i)
    {
        value += amplitude * snoise(position);
        position *= 2.0; 
        amplitude *= 0.5;
    }

    return value;
}

vec3 permute(vec3 x) {
  return mod((34.0 * x + 1.0) * x, 289.0);
}

vec2 cellular(vec3 P) {
	#define K 0.142857142857 // 1/7
	#define Ko 0.428571428571 // 1/2-K/2
	#define K2 0.020408163265306 // 1/(7*7)
	#define Kz 0.166666666667 // 1/6
	#define Kzo 0.416666666667 // 1/2-1/6*2
	#define jitter 1.0 // smaller jitter gives more regular pattern

	vec3 Pi = mod(floor(P), 289.0);
 	vec3 Pf = fract(P) - 0.5;

	vec3 Pfx = Pf.x + vec3(1.0, 0.0, -1.0);
	vec3 Pfy = Pf.y + vec3(1.0, 0.0, -1.0);
	vec3 Pfz = Pf.z + vec3(1.0, 0.0, -1.0);

	vec3 p = permute(Pi.x + vec3(-1.0, 0.0, 1.0));
	vec3 p1 = permute(p + Pi.y - 1.0);
	vec3 p2 = permute(p + Pi.y);
	vec3 p3 = permute(p + Pi.y + 1.0);

	vec3 p11 = permute(p1 + Pi.z - 1.0);
	vec3 p12 = permute(p1 + Pi.z);
	vec3 p13 = permute(p1 + Pi.z + 1.0);

	vec3 p21 = permute(p2 + Pi.z - 1.0);
	vec3 p22 = permute(p2 + Pi.z);
	vec3 p23 = permute(p2 + Pi.z + 1.0);

	vec3 p31 = permute(p3 + Pi.z - 1.0);
	vec3 p32 = permute(p3 + Pi.z);
	vec3 p33 = permute(p3 + Pi.z + 1.0);

	vec3 ox11 = fract(p11*K) - Ko;
	vec3 oy11 = mod(floor(p11*K), 7.0)*K - Ko;
	vec3 oz11 = floor(p11*K2)*Kz - Kzo; // p11 < 289 guaranteed

	vec3 ox12 = fract(p12*K) - Ko;
	vec3 oy12 = mod(floor(p12*K), 7.0)*K - Ko;
	vec3 oz12 = floor(p12*K2)*Kz - Kzo;

	vec3 ox13 = fract(p13*K) - Ko;
	vec3 oy13 = mod(floor(p13*K), 7.0)*K - Ko;
	vec3 oz13 = floor(p13*K2)*Kz - Kzo;

	vec3 ox21 = fract(p21*K) - Ko;
	vec3 oy21 = mod(floor(p21*K), 7.0)*K - Ko;
	vec3 oz21 = floor(p21*K2)*Kz - Kzo;

	vec3 ox22 = fract(p22*K) - Ko;
	vec3 oy22 = mod(floor(p22*K), 7.0)*K - Ko;
	vec3 oz22 = floor(p22*K2)*Kz - Kzo;

	vec3 ox23 = fract(p23*K) - Ko;
	vec3 oy23 = mod(floor(p23*K), 7.0)*K - Ko;
	vec3 oz23 = floor(p23*K2)*Kz - Kzo;

	vec3 ox31 = fract(p31*K) - Ko;
	vec3 oy31 = mod(floor(p31*K), 7.0)*K - Ko;
	vec3 oz31 = floor(p31*K2)*Kz - Kzo;

	vec3 ox32 = fract(p32*K) - Ko;
	vec3 oy32 = mod(floor(p32*K), 7.0)*K - Ko;
	vec3 oz32 = floor(p32*K2)*Kz - Kzo;

	vec3 ox33 = fract(p33*K) - Ko;
	vec3 oy33 = mod(floor(p33*K), 7.0)*K - Ko;
	vec3 oz33 = floor(p33*K2)*Kz - Kzo;

	vec3 dx11 = Pfx + jitter*ox11;
	vec3 dy11 = Pfy.x + jitter*oy11;
	vec3 dz11 = Pfz.x + jitter*oz11;

	vec3 dx12 = Pfx + jitter*ox12;
	vec3 dy12 = Pfy.x + jitter*oy12;
	vec3 dz12 = Pfz.y + jitter*oz12;

	vec3 dx13 = Pfx + jitter*ox13;
	vec3 dy13 = Pfy.x + jitter*oy13;
	vec3 dz13 = Pfz.z + jitter*oz13;

	vec3 dx21 = Pfx + jitter*ox21;
	vec3 dy21 = Pfy.y + jitter*oy21;
	vec3 dz21 = Pfz.x + jitter*oz21;

	vec3 dx22 = Pfx + jitter*ox22;
	vec3 dy22 = Pfy.y + jitter*oy22;
	vec3 dz22 = Pfz.y + jitter*oz22;

	vec3 dx23 = Pfx + jitter*ox23;
	vec3 dy23 = Pfy.y + jitter*oy23;
	vec3 dz23 = Pfz.z + jitter*oz23;

	vec3 dx31 = Pfx + jitter*ox31;
	vec3 dy31 = Pfy.z + jitter*oy31;
	vec3 dz31 = Pfz.x + jitter*oz31;

	vec3 dx32 = Pfx + jitter*ox32;
	vec3 dy32 = Pfy.z + jitter*oy32;
	vec3 dz32 = Pfz.y + jitter*oz32;

	vec3 dx33 = Pfx + jitter*ox33;
	vec3 dy33 = Pfy.z + jitter*oy33;
	vec3 dz33 = Pfz.z + jitter*oz33;

	vec3 d11 = dx11 * dx11 + dy11 * dy11 + dz11 * dz11;
	vec3 d12 = dx12 * dx12 + dy12 * dy12 + dz12 * dz12;
	vec3 d13 = dx13 * dx13 + dy13 * dy13 + dz13 * dz13;
	vec3 d21 = dx21 * dx21 + dy21 * dy21 + dz21 * dz21;
	vec3 d22 = dx22 * dx22 + dy22 * dy22 + dz22 * dz22;
	vec3 d23 = dx23 * dx23 + dy23 * dy23 + dz23 * dz23;
	vec3 d31 = dx31 * dx31 + dy31 * dy31 + dz31 * dz31;
	vec3 d32 = dx32 * dx32 + dy32 * dy32 + dz32 * dz32;
	vec3 d33 = dx33 * dx33 + dy33 * dy33 + dz33 * dz33;

	// Sort out the two smallest distances (F1, F2)

	// Do it right and sort out both F1 and F2
	vec3 d1a = min(d11, d12);
	d12 = max(d11, d12);
	d11 = min(d1a, d13); // Smallest now not in d12 or d13
	d13 = max(d1a, d13);
	d12 = min(d12, d13); // 2nd smallest now not in d13
	vec3 d2a = min(d21, d22);
	d22 = max(d21, d22);
	d21 = min(d2a, d23); // Smallest now not in d22 or d23
	d23 = max(d2a, d23);
	d22 = min(d22, d23); // 2nd smallest now not in d23
	vec3 d3a = min(d31, d32);
	d32 = max(d31, d32);
	d31 = min(d3a, d33); // Smallest now not in d32 or d33
	d33 = max(d3a, d33);
	d32 = min(d32, d33); // 2nd smallest now not in d33
	vec3 da = min(d11, d21);
	d21 = max(d11, d21);
	d11 = min(da, d31); // Smallest now in d11
	d31 = max(da, d31); // 2nd smallest now not in d31
	d11.xy = (d11.x < d11.y) ? d11.xy : d11.yx;
	d11.xz = (d11.x < d11.z) ? d11.xz : d11.zx; // d11.x now smallest
	d12 = min(d12, d21); // 2nd smallest now not in d21
	d12 = min(d12, d22); // nor in d22
	d12 = min(d12, d31); // nor in d31
	d12 = min(d12, d32); // nor in d32
	d11.yz = min(d11.yz,d12.xy); // nor in d12.yz
	d11.y = min(d11.y,d12.z); // Only two more to go
	d11.y = min(d11.y,d11.z); // Done! (Phew!)
	return sqrt(d11.xy); // F1, F2
}

vec2 voro_fbm(vec3 position, int octaves)
{
    vec2 value = vec2(0.0,0.0);
    float amplitude = 0.5;
    float frequency = 0.0;

    for (int i=0; i < octaves; ++i)
    {
        value += amplitude * cellular(position);
        position *= 2.0; 
        amplitude *= 0.5;
    }

    return value;
}

float distribution_function(vec3 position)
{
    position += vec3(
        snoise(position * 0.04) * 8,
        snoise(position * 0.03) * 7,
        snoise(position * 0.02) * 9);
    
    float density = -position.y - 15;

    density += fbm(position / 110.0, 6) * 5;
    density += voro_fbm(position / 70.0, 2).y * 40;

    return density;
}

//TODO: make this a macro so arbitrary functions can have a normal function generated
vec3 distribution_function_normal(vec3 position, float d)
{
    return normalize(vec3(
        (distribution_function(position + vec3(d,0,0)) - distribution_function(position - vec3(d,0,0))),
        (distribution_function(position + vec3(0,d,0)) - distribution_function(position - vec3(0,d,0))),
        (distribution_function(position + vec3(0,0,d)) - distribution_function(position - vec3(0,0,d)))
    ));
}

uint vertex_index(uvec3 pos) 
{
    return gl_NumWorkGroups.x * gl_NumWorkGroups.y * pos.z + gl_NumWorkGroups.x * pos.y + pos.x;
}

//FIXME: why are these "v0" and "v1" are these supposed to be vectors
float adapt(float v0, float v1)
{
    if ((v0 > 0) != (v1 > 0))
    {
        return (0 - v0) / (v1 - v0);
    }

    return 0.5;
}

#define STORAGE_INDEX vertex_index(gl_GlobalInvocationID)

void main() 
{
    //FIXME: the switches between world space (for noise) and local space (for indexing) aren't clear/well-documented

    vec3 offset = settings.offset.xyz;
    float voxel_size = settings.voxel_size;

    //local-space voxel position
    vec3 voxel_index = vec3(gl_GlobalInvocationID.x, gl_GlobalInvocationID.y, gl_GlobalInvocationID.z);

    //Defaulting to non-adaptive ( minecraft-esque )
    vec3 voxel_position = voxel_index * voxel_size + offset;

    //Evaluate at each corner
    float corner_density_values[2][2][2];
    for (int dx=0; dx<2; ++dx)
    {
        for (int dy=0; dy<2; ++dy)
        {
            for (int dz=0; dz<2; ++dz)
            {
                corner_density_values[dx][dy][dz] = distribution_function(voxel_position + (vec3(dx,dy,dz) * voxel_size));
            }
        }
    }

    vec3 points[12];
    int num_points = 0;

    for (int dx=0; dx<2; ++dx)
    {
        for (int dy=0; dy<2; ++dy)
        {
            if ( (corner_density_values[dx][dy][0] > 0) != (corner_density_values[dx][dy][1] > 0) )
            {
                points[num_points++] = voxel_position + vec3(dx,dy,adapt(corner_density_values[dx][dy][0], corner_density_values[dx][dy][1])) * voxel_size;
            }
        }
    }

    for (int dx=0; dx<2; ++dx)
    {
        for (int dz=0; dz<2; ++dz)
        {
            if ( (corner_density_values[dx][0][dz] > 0) != (corner_density_values[dx][1][dz] > 0) )
            {
                points[num_points++] = voxel_position + vec3(dx,adapt(corner_density_values[dx][0][dz], corner_density_values[dx][1][dz]), dz) * voxel_size;
            }
        }
    }

    for (int dy=0; dy<2; ++dy)
    {
        for (int dz=0; dz<2; ++dz)
        {
            if ( (corner_density_values[0][dy][dz] > 0) != (corner_density_values[1][dy][dz] > 0) )
            {
                points[num_points++] = voxel_position + vec3(adapt(corner_density_values[0][dy][dz], corner_density_values[1][dy][dz]), dy, dz) * voxel_size;
            }
        }
    }

    vec3 normals[12];
    for (int i=0; i < num_points; ++i)
    {
        normals[i] = distribution_function_normal(points[i], 0.01);
    }

    //Solve QEF
    vec4 pointaccum = vec4(0.0);
    mat3 ATA = mat3(0.0);
    vec3 ATb = vec3(0.0);

    for (int i=0; i < num_points; ++i)
    {
        qef_add(normals[i],points[i],ATA,ATb,pointaccum);
    }
    vec3 center_of_mass = pointaccum.xyz / pointaccum.w;
    //vec3 center_of_mass_normal = distribution_function_normal(center_of_mass,0.01);

    vec3 qef_result;
    float error = qef_solve(ATA,ATb,pointaccum,qef_result);

    //FIXME: quick fix for qef results that are way off
    if (length(qef_result - voxel_position) > voxel_size)
    {
        qef_result = center_of_mass;
    }

    //FIXME: QEF_Solve producing some pretty nasty results 

    vertices[STORAGE_INDEX].position = vec4(qef_result, 1.0);
    vertices[STORAGE_INDEX].normal = vec4(distribution_function_normal(qef_result,0.01), 1.0);

    //Zero Out Indices
    for (int i = 0; i < 18; ++i)
    {
        indices[STORAGE_INDEX][i] = -1;
    }

    if (voxel_index.x > 0 && voxel_index.y > 0)
    {
        bool solid1 = distribution_function(voxel_position) > 0.0;
        bool solid2 = distribution_function(voxel_position + vec3(0,0,voxel_size)) > 0.0;
        if (solid1 != solid2)
        {
            indices[STORAGE_INDEX][0] = int(vertex_index(uvec3(voxel_index.x - 1, voxel_index.y - 1, voxel_index.z)));
            indices[STORAGE_INDEX][1] = int(vertex_index(uvec3(voxel_index.x, voxel_index.y - 1, voxel_index.z)));
            indices[STORAGE_INDEX][2] = int(vertex_index(uvec3(voxel_index.x, voxel_index.y, voxel_index.z)));
            indices[STORAGE_INDEX][3] = int(vertex_index(uvec3(voxel_index.x, voxel_index.y, voxel_index.z)));
            indices[STORAGE_INDEX][4] = int(vertex_index(uvec3(voxel_index.x - 1, voxel_index.y, voxel_index.z)));
            indices[STORAGE_INDEX][5] = int(vertex_index(uvec3(voxel_index.x - 1, voxel_index.y - 1, voxel_index.z)));
        }
    }

    if (voxel_index.x > 0 && voxel_index.z > 0)
    {
        bool solid1 = distribution_function(voxel_position) > 0.0;
        bool solid2 = distribution_function(voxel_position + vec3(0,voxel_size,0)) > 0.0;
        if (solid1 != solid2)
        {
            indices[STORAGE_INDEX][6]  = int(vertex_index(uvec3(voxel_index.x - 1, voxel_index.y, voxel_index.z - 1)));
            indices[STORAGE_INDEX][7]  = int(vertex_index(uvec3(voxel_index.x, voxel_index.y, voxel_index.z - 1)));
            indices[STORAGE_INDEX][8]  = int(vertex_index(uvec3(voxel_index.x, voxel_index.y, voxel_index.z)));
            indices[STORAGE_INDEX][9]  = int(vertex_index(uvec3(voxel_index.x, voxel_index.y, voxel_index.z)));
            indices[STORAGE_INDEX][10] = int(vertex_index(uvec3(voxel_index.x - 1, voxel_index.y, voxel_index.z)));
            indices[STORAGE_INDEX][11] = int(vertex_index(uvec3(voxel_index.x - 1, voxel_index.y, voxel_index.z - 1)));
        }
    }

    if (voxel_index.y > 0 && voxel_index.z > 0)
    {
        bool solid1 = distribution_function(voxel_position) > 0.0;
        bool solid2 = distribution_function(voxel_position + vec3(voxel_size,0,0)) > 0.0;
        if (solid1 != solid2)
        {
            indices[STORAGE_INDEX][12] = int(vertex_index(uvec3(voxel_index.x, voxel_index.y - 1, voxel_index.z - 1)));
            indices[STORAGE_INDEX][13] = int(vertex_index(uvec3(voxel_index.x, voxel_index.y, voxel_index.z - 1)));
            indices[STORAGE_INDEX][14] = int(vertex_index(uvec3(voxel_index.x, voxel_index.y, voxel_index.z)));
            indices[STORAGE_INDEX][15] = int(vertex_index(uvec3(voxel_index.x, voxel_index.y, voxel_index.z)));
            indices[STORAGE_INDEX][16] = int(vertex_index(uvec3(voxel_index.x, voxel_index.y - 1, voxel_index.z)));
            indices[STORAGE_INDEX][17] = int(vertex_index(uvec3(voxel_index.x, voxel_index.y - 1, voxel_index.z - 1)));
        }
    }
}